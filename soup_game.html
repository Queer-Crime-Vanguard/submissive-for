<!doctype html>

<html>
<head>
  <meta charset="utf-8">

  <title>HandsOff Example</title>
  <meta name="description" content="HandsOff game page">
  <meta name="author" content="HandsOff">
</head>

<body onload="setTrack()">
  
  <link rel="stylesheet" href="styles.css">
  <script type="text/javascript" src="js/sprite.js"></script>
  <script type="text/javascript" src="js/track.js"></script>

  <style>
    body {
        margin: 0;
    }
    
    .background {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -2;
        background-image: url(assets/minigames/soup/bg.png);
        background-size: auto;
    }

    .blackout {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -1;
        background-color: rgba(0, 0, 100, 0.25);
    }

  </style>

  <div class="background"></div>
  <div class="blackout"></div>

  <script>

    // small method for choosing random element of array
    Array.prototype.sample = function(){
        return this[Math.floor(Math.random()*this.length)];
    }


    let game_canvas = document.createElement('canvas');
    game_canvas.classList.add("minigame");

    let context = game_canvas.getContext('2d');

    let alph_tiles_img = new Image();
    alph_tiles_img.src = "assets/minigames/soup/alphabet.png";

    const total_alph = 32;

    const alph_width = 50;
    const alph_height = 67;

    const offset_x = 30;
    const offset_y = 30;

    const wallRepulsionSoften = 0.7;

    const baseVelocity = 35;
    const initialAmplitude = 4;
    const smoothDec = (velocity) => {
        let k = 0.02;
        let dv = Math.max(velocity-baseVelocity, 0);
        return (dv*k)*(dv*k);
    }

    const spoonRepulsion = 5;

    const spoonRadialSpeed = 0.3;

    // words utilites
    
    const alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя';

    const goodWords = ['забота', 'отдых', 'сон']
    const badWords  = ['кусь']

    // UI

    let goodWord;
    let badWord;
    let found_letters;
    
    let main = () => {
        // choose words
        goodWord = goodWords.sample();
        badWord  = badWords.sample();
        found_letters = [];

        // generate letters

        let letters = new Array();

        let generate_letter = (c) => {
            let i = alphabet.indexOf(c);
            let sprite = new Sprite(alph_tiles_img, 11, 3, total_alph);
            let deg = 2*Math.PI*Math.random();
            let dx = Math.cos(deg);
            let dy = Math.sin(deg);
            let velocity = baseVelocity + initialAmplitude * baseVelocity * Math.random();
            sprite.setFrame(i);
            letters.push({
                'char': c,
                'sprite': sprite,
                'pos_x': width*Math.random(),
                'pos_y': height*Math.random(),
                'dir_x': dx,
                'dir_y': dy,
                'velocity': velocity,
                'repulsed_x': false,
                'repulsed_y': false
            })
        }

        for (c of goodWord) {
            generate_letter(c)
        }

        // junk

        let remaining_letters = [];

        for (c of alphabet) {
            if (!goodWord.includes(c)) {remaining_letters.push(c)}
        }

        for (let t = 0; t < 20; t += 1) {
            generate_letter(remaining_letters.sample())
        }

        // interact with letter

        let interact = (letter) => {
            if (goodWord.includes(letter.char)) {
                found_letters.push(letter.char)
                console.log(found_letters);
                letters.splice(letters.indexOf(letter), 1)
            }
        }
        
        // initiate spoon
        let spoonDeg = 0;
        let spoon_x, spoon_y;
        
        const updatePhysics = (delta) => {

            // update spoon Position
            const spoonRadius = Math.min(width, height)*0.5*0.75;
            const repulsionRadius = spoonRadius/2;
            
            spoonDeg += spoonRadialSpeed*delta;
            spoon_x = (width/2)  + spoonRadius * Math.cos(spoonDeg);
            spoon_y = (height/2) + spoonRadius * Math.sin(spoonDeg);

            for (let letter of letters) {

                // decrease velocity (fluid motion)
                letter.velocity -= smoothDec(letter.velocity)*delta
                
                // wall repulsion
                if ( letter.pos_x < -offset_x || 
                     letter.pos_x + alph_width > width + offset_x ) 
                { 
                    if (!letter.repulsed_x)
                    {
                        letter.dir_x = -letter.dir_x;
                        letter.velocity *= wallRepulsionSoften;
                        letter.repulsed_x = true;
                    }
                } else {
                    letter.repulsed_x = false;
                }
                if ( letter.pos_y < -offset_y ||
                     letter.pos_y + alph_height > height + offset_y )
                { 
                    if (!letter.repulsed_y)
                    {
                        letter.dir_y = -letter.dir_y;
                        letter.velocity *= wallRepulsionSoften;
                        letter.repulsed_y = true;
                    }
                } else {
                        letter.repulsed_y = false;
                }
                
                let center_x = letter.pos_x + alph_width/2;
                let center_y = letter.pos_y + alph_height/2;
                
                // add impulse with spoon
                let dx = center_x-spoon_x;
                let dy = center_y-spoon_y;
                let dr = dx*dx + dy*dy;
                let k = Math.min(repulsionRadius*repulsionRadius/dr, 2);
                if (k > 1) { // <=> cursos is in the range
                    let rep_x = -Math.sin(spoonDeg)*(k-1)*spoonRepulsion;
                    let rep_y = Math.cos(spoonDeg)*(k-1)*spoonRepulsion;
                    let v_x = letter.dir_x*letter.velocity + rep_x;
                    let v_y = letter.dir_y*letter.velocity + rep_y;
                    let nv = Math.sqrt(v_x*v_x + v_y*v_y);
                    letter.dir_x = v_x / nv;
                    letter.dir_y = v_y / nv;
                    letter.velocity = nv;
                }

                // interact on mouse
                let mdx = center_x-mouseOffsetX;
                let mdy = center_y-mouseOffsetY;

                if (Math.abs(mdx) < offset_x &&
                    Math.abs(mdy) < offset_y) {
                    interact(letter);
                }

                // apply velocity to position
                letter.pos_x += letter.dir_x*letter.velocity*delta;
                letter.pos_y += letter.dir_y*letter.velocity*delta;
                
            }
            
        }

        const drawFrame = () => {
            context.clearRect(0, 0, width, height);
            for (let letter of letters) {
                context.drawImage(letter.sprite.frame,
                                  letter.pos_x, 
                                  letter.pos_y, 
                                  alph_width,
                                  alph_height);
                
                context.font = '48px sans-serif';
                let word_offset = 0;
                for (let c of goodWord) {
                    if (found_letters.includes(c)) {
                        context.fillStyle = "green";
                    } else {
                        context.fillStyle = "white";
                    }
                    context.fillText(c,
                                     10+word_offset,
                                     48)
                    word_offset += context.measureText(c).width + 5;
                }

                context.strokeStyle = "white";
                context.strokeRect(mouseOffsetX-7,
                                mouseOffsetY-7,
                                15,
                                15);

                // test repulsion
                /* 
                if (letter.repulsed_x || letter.repulsed_y) {
                    context.strokeRect(letter.pos_x, 
                                  letter.pos_y, 
                                  alph_width,
                                  alph_height)
                }
                */ 
            }
            // spoon debug
            /*
            context.fillRect(spoon_x-2,
                             spoon_y-2,
                             5,
                             5)
           */ 
        }

        var prev_ts = null;
        const step = (ts) => {
            if (prev_ts) {
                delta = (ts - prev_ts)/1000;
            } else {
                delta = 0;
            }
            prev_ts = ts;
            updatePhysics(delta);
            drawFrame();
            window.requestAnimationFrame(step);
        }

        window.requestAnimationFrame(step);
    }

    window.addEventListener("size_update", () => {
        game_canvas.width = width;
        game_canvas.height = height;
        alph_tiles_img.onload = main;
        if (alph_tiles_img.complete) {main();}
    })

    document.body.appendChild(game_canvas);

  </script>

</body>
</html>
