<!doctype html>

<html>
<head>
  <meta charset="utf-8">

  <title>HandsOff Example</title>
  <meta name="description" content="HandsOff game page">
  <meta name="author" content="HandsOff">
</head>

<body onload="setTrack()">
  
  <link rel="stylesheet" href="styles.css">
  <script type="text/javascript" src="js/sprite.js"></script>
  <script type="text/javascript" src="js/track.js"></script>

  <style>
    body {
        margin: 0;
    }
    
    .background {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -2;
        background-image: url(assets/minigames/soup/bg.png);
        background-size: auto;
    }

    .blackout {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -1;
        background-color: rgba(0, 0, 100, 0.25);
    }

  </style>

  <div class="background"></div>
  <div class="blackout"></div>

  <script>

    // small method for choosing random element of array
    Array.prototype.sample = function(){
        return this[Math.floor(Math.random()*this.length)];
    }


    let game_canvas = document.createElement('canvas');
    game_canvas.classList.add("minigame");

    let context = game_canvas.getContext('2d');

    let alph_tiles_img = new Image();
    alph_tiles_img.src = "assets/minigames/soup/alphabet.png";

    const total_alph = 32;

    const alph_width = 50;
    const alph_height = 67;

    const offset_x = 30;
    const offset_y = 30;

    const wallRepulsionSoften = 0.7;

    const baseVelocity = 35;
    const initialAmplitude = 4;
    const smoothDec = (velocity) => {
        let k = 0.02;
        let dv = Math.max(velocity-baseVelocity, 0);
        return (dv*k)*(dv*k);
    }

    const spoonRepulsion = 5;

    const spoonRadialSpeed = 0.3;

    // words utilites
    
    const alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя';

    const goodWords = ['забота', 'отдых', 'сон']
    const badWords  = ['кусь']

    // UI

    let goodWord;
    let badWord;
    let found_letters;
    
    let main = () => {
        // choose words
        goodWord = goodWords.sample();
        badWord  = badWords.sample();
        found_letters = [];

        // generate letters

        let letters = new Array();

        let total_letters = goodWord.length + 20;

        let spiral = Math.min(width, height)/2;
        const spiral_turns = 4;
        const start_offset = 25;

        let generate_letter = (char, n) => {
            let i = alphabet.indexOf(char);
            let sprite = new Sprite(alph_tiles_img, 11, 3, total_alph);
            let dir = Math.random()*2*Math.PI;
            let dir_x = Math.cos(dir);
            let dir_y = Math.sin(dir);
            let velocity = 3*baseVelocity;
            sprite.setFrame(i);
            let r = spiral*((n+start_offset)/(total_letters+start_offset));
            let d = (n/total_letters)*2*Math.PI*spiral_turns;
            home_pos_x = width/2 + r*Math.cos(d);
            home_pos_y = height/2 + r*Math.sin(d);
            letters.push({
                char,
                sprite,
                home_pos_x,
                home_pos_y,
                'pos_x': home_pos_x,
                'pos_y': home_pos_y,
                dir_x,
                dir_y,
                velocity,
                'repulsed_x': false,
                'repulsed_y': false,
                'disentangled': false
            })
        }

        n = 0;
        for (c of goodWord) {
            generate_letter(c, n)
            n += 1;
        }

        // junk

        let remaining_letters = [];

        for (c of alphabet) {
            if (!goodWord.includes(c)) {remaining_letters.push(c)}
        }

        for (let t = 0; t < 20; t += 1) {
            generate_letter(remaining_letters.sample(), n)
            n += 1;
        }

        // interact with letter

        let interact = (letter) => {
            if (goodWord.includes(letter.char)) {
                found_letters.push(letter.char)
                letters.splice(letters.indexOf(letter), 1)
            }
        }
        
        // initiate spoon
        let spoonDeg = 0;
        let spoon_x, spoon_y;

        // total time
        let total_time = 0;

        // pulsar for moving
        const spread = 3.5;
        const intensity = 0.1;
        const center_speed = 0.1;
        let pulsar = (x, y) => {
            waves = intensity*total_time;
            walk = center_speed*total_time;
            return -Math.sin(-spread*Math.sqrt((x-0.7*Math.cos(walk))**2+(y-0.7*Math.cos(walk))**2))
        }
        
        const updatePhysics = (delta) => {

            total_time += delta;

            // update spoon Position
            const spoonRadius = Math.min(width, height)*0.5*0.75;
            const repulsionRadius = spoonRadius/2;
            
            spoonDeg += spoonRadialSpeed*delta;
            spoon_x = (width/2)  + spoonRadius * Math.cos(spoonDeg);
            spoon_y = (height/2) + spoonRadius * Math.sin(spoonDeg);

            for (let letter of letters) {

                // decrease velocity (fluid motion)
                letter.velocity -= smoothDec(letter.velocity)*delta
                
                // wall repulsion
                if ( letter.pos_x < -offset_x || 
                     letter.pos_x + alph_width > width + offset_x ) 
                { 
                    if (!letter.repulsed_x)
                    {
                        letter.dir_x = -letter.dir_x;
                        letter.velocity *= wallRepulsionSoften;
                        letter.repulsed_x = true;
                    }
                } else {
                    letter.repulsed_x = false;
                }
                if ( letter.pos_y < -offset_y ||
                     letter.pos_y + alph_height > height + offset_y )
                { 
                    if (!letter.repulsed_y)
                    {
                        letter.dir_y = -letter.dir_y;
                        letter.velocity *= wallRepulsionSoften;
                        letter.repulsed_y = true;
                    }
                } else {
                        letter.repulsed_y = false;
                }
                
                // interact on mouse

                let center_x = letter.pos_x + alph_width/2;
                let center_y = letter.pos_y + alph_height/2;

                let mdx = center_x-mouseOffsetX;
                let mdy = center_y-mouseOffsetY;

                if (Math.abs(mdx) < offset_x &&
                    Math.abs(mdy) < offset_y) {
                    letter.disentangled = true;
                } else {
                    letter.disentangled = false;
                }

                let pre_v_x = letter.dir_x*letter.velocity;
                let pre_v_y = letter.dir_y*letter.velocity;

                // home tension

                const ht = 0.7;

                let dx = letter.pos_x - letter.home_pos_x;
                let dy = letter.pos_y - letter.home_pos_y;

                let dr = Math.sqrt(dx*dx + dy*dy);

                let t_dfx = -ht*dx*Math.sqrt(dr);
                let t_dfy = -ht*dy*Math.sqrt(dr);

                const hg = -700;

                let drs = dr + 1;

                let g_dfx = hg*dx/(drs*drs);
                let g_dfy = hg*dy/(drs*drs);

                let dvx = (t_dfx + g_dfx)*delta;
                let dvy = (t_dfy + g_dfy)*delta;

                // pulsar velocity

                let npos_x = 2*letter.pos_x/width - 1;
                let npos_y = 2*letter.pos_y/height - 1;

                const step = 0.01;

                let pv = pulsar(npos_x, npos_y);
                let dpx = (pulsar(npos_x+step, npos_y) - pv)/step;
                let dpy = (pulsar(npos_x, npos_y+step) - pv)/step;

                const amp = 0;

                // apply forces to velocity

                if (letter.disentangled) {
                    dvx = 0;
                    dvy = 0;
                }

                let ss = (1-(1/drs));

                let v_x = pre_v_x + dvx + dpx*delta;
                let v_y = pre_v_y + dvy + dpx*delta;

                let nv = Math.sqrt(v_x*v_x + v_y*v_y);
                letter.dir_x = v_x / nv;
                letter.dir_y = v_y / nv;
                letter.velocity = nv;

                const slow = 0.02;
                const vel_amp = 30;

                // apply velocity to position
                letter.pos_x += vel_amp*2*Math.atan(slow*v_x)*delta / Math.PI;
                letter.pos_y += vel_amp*2*Math.atan(slow*v_y)*delta / Math.PI;
                
            }
            
        }

        const drawFrame = () => {
            context.clearRect(0, 0, width, height);
            for (let letter of letters) {
                context.drawImage(letter.sprite.frame,
                                  letter.pos_x, 
                                  letter.pos_y, 
                                  alph_width,
                                  alph_height);
                
                context.font = '48px sans-serif';
                let word_offset = 0;
                let remaining_found_letters = [...found_letters];
                for (let c of goodWord) {
                    let i = remaining_found_letters.indexOf(c);
                    if (i >= 0) {
                        context.fillStyle = "green";
                        remaining_found_letters.splice(i, 1);
                    } else {
                        context.fillStyle = "white";
                    }
                    context.fillText(c,
                                     10+word_offset,
                                     48)
                    word_offset += context.measureText(c).width + 5;
                }

                context.strokeStyle = "white";
                context.strokeRect(mouseOffsetX-7,
                                mouseOffsetY-7,
                                15,
                                15);

                // test repulsion
                /* 
                if (letter.repulsed_x || letter.repulsed_y) {
                    context.strokeRect(letter.pos_x, 
                                  letter.pos_y, 
                                  alph_width,
                                  alph_height)
                }
                */ 
            }
            // spoon debug
            /*
            context.fillRect(spoon_x-2,
                             spoon_y-2,
                             5,
                             5)
           */ 
        }

        var prev_ts = null;
        const step = (ts) => {
            if (prev_ts) {
                delta = (ts - prev_ts)/1000;
            } else {
                delta = 0;
            }
            prev_ts = ts;
            updatePhysics(delta);
            drawFrame();
            window.requestAnimationFrame(step);
        }

        window.requestAnimationFrame(step);
    }

    window.addEventListener("size_update", () => {
        game_canvas.width = width;
        game_canvas.height = height;
        alph_tiles_img.onload = main;
        if (alph_tiles_img.complete) {main();}
    })

    document.body.appendChild(game_canvas);

  </script>

</body>
</html>
